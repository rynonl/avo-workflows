# frozen_string_literal: true

require 'rails_helper'

RSpec.describe Avo::Workflows::Forms::AutoGeneratedForm do
  # Test workflow with panel definitions
  let(:test_workflow_class) do
    Class.new(Avo::Workflows::Base) do
      def self.name; 'TestWorkflow'; end

      step :draft do
        describe 'Document is being drafted'
        
        panel do
          field :title, as: :text, required: true, label: 'Document Title'
          field :content, as: :textarea, required: true, help: 'Main content'
          field :category, as: :select, options: ['blog', 'news', 'announcement']
          field :urgent, as: :boolean, default: false
          field :publish_date, as: :date
          field :rating, as: :number, min: 1, max: 10
        end
      end

      step :review do
        describe 'Document under review'
        
        panel do
          field :reviewer_comments, as: :textarea, required: true
          field :quality_score, as: :number, min: 1, max: 10, required: true
        end
      end

      step :approved do
        describe 'Document approved'
        # No panel - final state
      end
    end
  end

  describe '.for_step' do
    context 'with step that has panel fields' do
      let(:form_class) { described_class.for_step(test_workflow_class, :draft) }
      
      it 'returns a form class' do
        expect(form_class).to be_a(Class)
        expect(form_class.ancestors).to include(Avo::Workflows::Forms::Base)
      end

      it 'sets form metadata from step definition' do
        expect(form_class.form_title).to eq('Document is being drafted')
        expect(form_class.form_description).to eq('Auto-generated form for TestWorkflow draft step')
      end

      it 'generates meaningful class name' do
        expect(form_class.name).to eq('TestWorkflowDraftForm')
      end

      it 'stores references to workflow and step' do
        expect(form_class.workflow_class).to eq(test_workflow_class)
        expect(form_class.step_name).to eq(:draft)
        expect(form_class.step_definition).to eq(test_workflow_class.find_step(:draft))
      end

      it 'creates all panel fields' do
        field_names = form_class.field_definitions.map { |f| f[:name] }
        expect(field_names).to eq([:title, :content, :category, :urgent, :publish_date, :rating])
      end

      it 'preserves field types correctly' do
        fields = form_class.field_definitions
        
        title_field = fields.find { |f| f[:name] == :title }
        expect(title_field[:type]).to eq(:text)
        expect(title_field[:options][:required]).to be true
        expect(title_field[:options][:label]).to eq('Document Title')

        content_field = fields.find { |f| f[:name] == :content }
        expect(content_field[:type]).to eq(:textarea)
        expect(content_field[:options][:required]).to be true
        expect(content_field[:options][:help]).to eq('Main content')

        category_field = fields.find { |f| f[:name] == :category }
        expect(category_field[:type]).to eq(:select)
        expect(category_field[:options][:options]).to eq({
          'Blog' => 'blog',
          'News' => 'news', 
          'Announcement' => 'announcement'
        })

        urgent_field = fields.find { |f| f[:name] == :urgent }
        expect(urgent_field[:type]).to eq(:boolean)
        expect(urgent_field[:options][:default]).to be false

        rating_field = fields.find { |f| f[:name] == :rating }
        expect(rating_field[:type]).to eq(:number)
        expect(rating_field[:options][:min]).to eq(1)
        expect(rating_field[:options][:max]).to eq(10)
      end
    end

    context 'with step that has no panel fields' do
      it 'returns nil for step without panel' do
        form_class = described_class.for_step(test_workflow_class, :approved)
        expect(form_class).to be_nil
      end
    end

    context 'with non-existent step' do
      it 'returns nil for non-existent step' do
        form_class = described_class.for_step(test_workflow_class, :nonexistent)
        expect(form_class).to be_nil
      end
    end
  end

  describe '.for_workflow' do
    let(:workflow_forms) { described_class.for_workflow(test_workflow_class) }

    it 'returns forms for all steps with panels' do
      expect(workflow_forms.keys).to eq([:draft, :review])
      expect(workflow_forms[:draft]).to be_a(Class)
      expect(workflow_forms[:review]).to be_a(Class)
    end

    it 'excludes steps without panels' do
      expect(workflow_forms[:approved]).to be_nil
    end

    it 'creates properly named form classes' do
      expect(workflow_forms[:draft].name).to eq('TestWorkflowDraftForm')
      expect(workflow_forms[:review].name).to eq('TestWorkflowReviewForm')
    end
  end

  describe 'generated form instances' do
    let(:form_class) { described_class.for_step(test_workflow_class, :draft) }
    let(:form_instance) do
      form_class.new(
        title: 'Test Document',
        content: 'This is test content',
        category: 'blog',
        urgent: true,
        rating: 8
      )
    end

    it 'creates valid form instances' do
      expect(form_instance).to be_valid
    end

    it 'validates required fields' do
      invalid_form = form_class.new(title: '', content: 'Some content')
      expect(invalid_form).not_to be_valid
      expect(invalid_form.errors[:title]).to include("can't be blank")
    end

    it 'converts to context correctly' do
      context = form_instance.to_context
      expect(context).to eq({
        title: 'Test Document',
        content: 'This is test content',
        category: 'blog',
        urgent: true,
        rating: 8
      })
    end

    it 'excludes blank values from context' do
      form_with_blanks = form_class.new(
        title: 'Test',
        content: 'Content',
        category: '',  # blank
        urgent: false,
        rating: nil    # blank
      )
      
      context = form_with_blanks.to_context
      expect(context).to eq({
        title: 'Test',
        content: 'Content',
        urgent: false  # false is included since it's an explicit value
      })
    end
  end

  describe 'field type mapping' do
    let(:mapping_tests) do
      [
        { panel_type: :text, form_type: :text },
        { panel_type: :textarea, form_type: :textarea },
        { panel_type: :boolean, form_type: :boolean },
        { panel_type: :select, form_type: :select },
        { panel_type: :date, form_type: :date },
        { panel_type: :datetime, form_type: :datetime },
        { panel_type: :number, form_type: :number },
        { panel_type: :integer, form_type: :number },
        { panel_type: :decimal, form_type: :decimal },
        { panel_type: :float, form_type: :decimal },
        { panel_type: :hidden, form_type: :hidden },
        { panel_type: :email, form_type: :email },
        { panel_type: :url, form_type: :url },
        { panel_type: :password, form_type: :password },
        { panel_type: :unknown_type, form_type: :text } # fallback
      ]
    end

    it 'maps panel field types to form field types correctly' do
      mapping_tests.each do |test|
        mapped_type = described_class.send(:map_panel_field_type, test[:panel_type])
        expect(mapped_type).to eq(test[:form_type]), 
          "Expected #{test[:panel_type]} to map to #{test[:form_type]}, got #{mapped_type}"
      end
    end
  end

  describe 'option conversion' do
    it 'converts direct mapping options correctly' do
      panel_options = {
        required: true,
        label: 'Test Label',
        help: 'Test Help',
        placeholder: 'Enter text',
        default: 'default value',
        min: 1,
        max: 100,
        readonly: true
      }
      
      form_options = described_class.send(:convert_panel_options_to_form_options, panel_options, :text)
      expect(form_options).to eq(panel_options)
    end

    it 'normalizes select options from array' do
      panel_options = { options: ['low', 'medium', 'high'] }
      form_options = described_class.send(:convert_panel_options_to_form_options, panel_options, :select)
      
      expect(form_options[:options]).to eq({
        'Low' => 'low',
        'Medium' => 'medium', 
        'High' => 'high'
      })
    end

    it 'preserves select options when already a hash' do
      panel_options = { options: { 'Low Priority' => 'low', 'High Priority' => 'high' } }
      form_options = described_class.send(:convert_panel_options_to_form_options, panel_options, :select)
      
      expect(form_options[:options]).to eq({ 'Low Priority' => 'low', 'High Priority' => 'high' })
    end

    it 'handles validation options' do
      panel_options = {
        required: true,
        validation: {
          length: { minimum: 5, maximum: 100 },
          format: { with: /\A[a-zA-Z]+\z/ }
        }
      }
      
      form_options = described_class.send(:convert_panel_options_to_form_options, panel_options, :text)
      expect(form_options[:required]).to be true
      expect(form_options[:length]).to eq({ minimum: 5, maximum: 100 })
      expect(form_options[:format]).to eq({ with: /\A[a-zA-Z]+\z/ })
    end
  end

  describe 'integration with existing forms system' do
    let(:form_class) { described_class.for_step(test_workflow_class, :review) }
    
    it 'integrates with ActiveModel validations' do
      form_instance = form_class.new(reviewer_comments: '', quality_score: nil)
      expect(form_instance).not_to be_valid
      expect(form_instance.errors[:reviewer_comments]).to include("can't be blank")
      expect(form_instance.errors[:quality_score]).to include("can't be blank")
    end

    it 'supports all standard form features' do
      form_instance = form_class.new(
        reviewer_comments: 'Great work!',
        quality_score: 9
      )
      
      expect(form_instance).to be_valid
      expect(form_instance.reviewer_comments).to eq('Great work!')
      expect(form_instance.quality_score).to eq(9)
      expect(form_instance.to_context).to eq({
        reviewer_comments: 'Great work!',
        quality_score: 9
      })
    end
  end

  describe 'error handling' do
    it 'handles workflow class without steps gracefully' do
      empty_workflow = Class.new(Avo::Workflows::Base) do
        def self.name; 'EmptyWorkflow'; end
      end
      
      forms = described_class.for_workflow(empty_workflow)
      expect(forms).to eq({})
    end

    it 'handles step without panel gracefully' do
      workflow_without_panels = Class.new(Avo::Workflows::Base) do
        def self.name; 'NoPanelWorkflow'; end
        
        step :simple do
          action :proceed, to: :done
        end
        
        step :done
      end
      
      form_class = described_class.for_step(workflow_without_panels, :simple)
      expect(form_class).to be_nil
    end
  end
end